```   ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡈⢯⡉⠓⠦⣄⡀⠀⠀⠀⠀⠀⠀ ____ _     ____  ____  _____ ____  _     _  _____ _____  _____ ____
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣉⠹⠷⠀⠀⠀⠙⢷⡀⠀⠀⠀⠀/ ___\/ \ /|/  _ \/  __\/  __// ___\/ \ /|/ \/    //__ __\/  __//  __\
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠀⠀⠀⠀⠀⠀⠀⢿⡇⠀⠀⠀|    \| |_||| / \||  \/||  \  |    \| |_||| ||  __\  / \  |  \  |  \/|
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⢈⡇⠀⠀⠀\___ || | ||| |-|||  __/|  /_ \___ || | ||| || |     | |  |  /_ |    /
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠹⠝⠀⠀⠀⠀⠀⣼⠃⠀⠀⠀\____/\_/ \|\_/ \|\_/   \____\\____/\_/ \|\_/\_/     \_/  \____\\_/\_\
⠀ ⠀⠀⠀⠀⠀⠀⠀⣠⠞⠀⣀⣠⣤⣤⠄⠀⠀⢠⡏⠀⠀⠀⠀
⠀ ⠀⠀⠀⠀⠀⠀⠚⠢⠼⠿⠟⢛⣾⠃⠀⠀⠀⢸⡇⠀⠀⠀⠀ _     _____ _     ____  _____ ____
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⣻⠃⠀⠀⠀⠀⢸⡉⠀⠀⠀⠀/ \ /|/  __// \   /  __\/  __//  __\
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⣰⢻⡷⠁⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀| |_|||  \  | |   |  \/||  \  |  \/|
⠀ ⠀⠀⠀⠀⠀⠀⠀⢰⢽⡟⠁⠀⠀⠀⠀⠀⠀⠀⣇⠀⠀⠀⠀| | |||  /_ | |_/\|  __/|  /_ |    /
⠀ ⠀⠀⠀⠀⠀⠀⠀⢾⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⡆⠀⠀⠀\_/ \|\____\\____/\_/   \____\\_/\_\
⠀ ⠀⠀⠀⠀⠀⠀⠀⢸⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡀⠀⠀⠀⠀⠀⠀⠀
⠀ ⠀⠀⠀⠀⠀⠀⠀⠘⢧⣳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣷⠀⠀⠀⠀⠀⠀⠀ Version 2.0.2
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠈⣷⣱⡀⠀⠀⠀⠀⣸⠀⠀⠀⠈⢻⣦⠀⠀⠀⠀⠀     
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣷⡙⣆⠀⠀⣾⠃⠀⠀⠀⠀⠈⢽⡆⠀⠀⠀⠀ CSharp Application by @willnjohnson
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⡇⢷⡏⠃⢠⠇⠀⠀⣀⠄⠀⠀⠀⣿⡖⠀⠀⠀      
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡇⢨⠇⠀⡼⢀⠔⠊⠀⠀⠀⠀⠀⠘⣯⣄⢀⠀ Algorithm by Kvho
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⡇⣼⡀⣰⣷⠁⠀⠀⠀⠀⠀⠀⠀⠀⣇⢻⣧⡄      
⠀ ⠀⠀⠀⠀⠀⠀⣀⣮⣿⣿⣿⣯⡭⢉⠟⠛⠳⢤⣄⣀⣀⣀⣀⡴⢠⠨⢻⣿      
⠀ ⠀   ⢀⣾⣿⣿⣿⣿⢏⠓⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢨⣿      
⠀    ⣰⣿⣿⣿⣿⣿⣿⡱⠌⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢭⣾⠏      
    ⣰⡿⠟⠋⠛⢿⣿⣿⣊⠡⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣼⡿⠋⠀
   ⠋⠁⠀⠀⠀⠀⠈⠑⠿⢶⣄⣀⣀⣀⣀⣀⣄⣤⡶⠿⠟⠋⠁⠀⠀⠀
```

# Shapeshifter Helper

This C# application helps you solve the Neopets Shapeshifter puzzle by utilizing a highly optimized search algorithm to find the optimal sequence of token puzzle piece placements. A DLL is included for native C performance (and must be included in the same directory as your `.exe`).

The compiled `.exe` and `.dll` can be found under the **[Releases](https://github.com/willnjohnson/ShapeshifterHelper/releases)** section of this GitHub repository.

You can add this **[GreaseMonkey script](https://raw.githubusercontent.com/willnjohnson/ShapeshifterHelper/refs/heads/master/ShapeshifterHelperWebVisualizer.js)** to your GreaseMonkey/TamperMonkey extension in your browser for easier convenience:
* "Copy HTML" button
* Symbols replaced with background and number (like you see in the C# application)

## Trouble Downloading?

The executable (.EXE) and Dynamic Link Library (.DLL) files for Release 2.0.1 and above may be flagged by your operating system's built-in security features (like Windows Defender or SmartScreen).

Rest assured, this is a known false positive. The program includes dynamically loading a native C DLL (i.e. a DLL of Kvho's Shapeshifter algorithm), which some security software can mistakenly interpret as suspicious behavior (such as "DLL injection" or "code modification" techniques that malware also employs). The files are safe and do not contain any malicious code.

You may need to temporarily disable Windows Defender, go to "Add or remove exclusions" to whitelist the executable and DLL, then re-enable Windows Defender.

If you're feeling skeptical, you can run the .EXE without the .DLL. Just be aware the solver may run slower if you do that.

## App Preview
https://github.com/user-attachments/assets/3ff799c7-6512-40ff-b6db-7e32f3ba4589

## Puzzle Data
* **Grid Layout:** The main puzzle grid ($M \times N$ board).
* **Token Layouts:** Some $K$ number of puzzle pieces.

## Features

* **HTML Parsing:** Automatically extracts the puzzle grid and token shapes from the provided Neopets HTML source.
* **Efficient Solving:** Employs an efficient search algorithm for optimal solutions.
* **Progress Tracking:** Provides real-time updates on the number of expanded search nodes.
* **Cancellation Support:** Allows you to stop the solving process at any time.

## Requirements

* **Operating System:** Windows (for the `.exe` release).
* **.NET Framework:** The application is built using .NET (likely .NET Framework 4.7.2 or later, or .NET 6/7/8). Ensure you have the appropriate runtime installed if running from source or if the executable doesn't run directly.

## Usage

1.  **Copy both `Shapeshifter_Helper.exe` and `ShapeshifterKvho.dll` into the SAME directory.**.
2.  **Run the `Shapeshifter_Helper.exe` application.**
3.  **Paste the relevant HTML source** of the Neopets Shapeshifter puzzle into the input text box.
4.  **Click the "Start" button** to begin the solving process.
5.  **Click "Stop"** to cancel an ongoing search (recommended if progress is slowing down).

* Note: DLL runs a C native version of the algorithm for quicker results. Without the DLL, the algorithm will run under its own environment.
* `Tip: If you cannot find a solution, lose the game on purpose to generate a new puzzle, and try again.`

## Output

Once a solution is found (or the search is cancelled/exhausted), the results will be displayed in the application's "Steps" panel. Each step will indicate the original token number (e.g., "Step 01:") and its recommended placement coordinates (e.g., "Row 3, Column 2"). You can check off steps as you complete them in the game.

A preview of the token placement (white) on the board is displayed on the right-hand side, as a quick guidance.

## Algorithms

Solving the Shapeshifter puzzle involves finding a sequence of token placements that transform an initial grid into a completely solved grid (i.e. grid with all swords). This is a classic search problem, and various algorithms can be employed, each with different performance characteristics. Let's consider a few:

Let the grid dimensions be $M \times N$.
Let $K$ be the number of tokens.
Let $P$ be the maximum number of possible placement positions for a single token on the grid (approximately $M \times N$ for small tokens, potentially less for larger ones that don't fit in all orientations).
Let $D$ be the depth of the solution (number of tokens placed in the optimal path, $D \le K$).

### Approach 1: Recursive Bruteforce (Depth-First Search)

A simple recursive bruteforce approach would try to place each token in every possible valid position, then recursively call itself with the remaining tokens and the updated grid.

* **Time Complexity:** $O(P^K \cdot K \cdot MN)$. In the worst case, for each of $K$ tokens, you might try $P$ positions. At each step, placing a token and checking validity might involve iterating over its points and updating $MN$ grid cells. This quickly becomes astronomically large, making it impractical for puzzles with many tokens.
* **Space Complexity:** $O(K \cdot MN)$. The space is primarily for the recursion stack, which goes as deep as $K$ (the number of tokens). Each stack frame stores a copy of the grid state (which takes $O(MN)$ space) and remaining tokens.

### Approach 2: A\* Search

A\* search is an informed search algorithm that uses a heuristic function to guide its search. It maintains an "open list" (priority queue) of states to explore and a "closed list" (hash set) of already explored states to avoid redundant computations and cycles. It guarantees finding the optimal solution (shortest path) if the heuristic is admissible and consistent.

* **Heuristic:** For Shapeshifter, a simple admissible heuristic is the number of filled cells in the grid. Each token placement either reduces the number of filled cells or changes their configuration. The goal state has 0 filled cells. This heuristic is admissible because placing one token can reduce the filled cells by at most the token's area, but it costs 1 "step". It's consistent as well.
* **Time Complexity:** In general graphs, $O(E \log V)$ or $O(E)$ with Fibonacci heaps, where $V$ is the number of vertices (states) and $E$ is the number of edges (transitions between states). For puzzle problems, it's often described as exponential in the branching factor and solution depth, but significantly reduced by a good heuristic. $O(P^D)$ in the worst case, but the heuristic helps prune large parts of the search tree. The actual complexity depends heavily on the problem's branching factor and the quality of the heuristic.
* **Space Complexity:** $O(V_{visited} \cdot MN)$, where $V_{visited}$ is the number of unique states visited and stored in memory. A\* stores all visited states in the `explored` (closed) set and `frontier` (open) list. For complex puzzles, this can lead to massive memory consumption, as the number of reachable states can be very large.

### Approach 3: Iterative Deepening A\* (IDA\*)

IDA\* combines the best features of A\* and iterative deepening depth-first search. It performs a series of depth-limited DFS searches, gradually increasing the cost limit (bound) in each iteration. The bound for the next iteration is the minimum f-score ($g + h$) of any node that exceeded the current bound.

* **Advantages over A\*:**
    * **Optimal:** Like A\*, it guarantees finding the optimal solution if the heuristic is admissible.
    * **Memory Efficient:** It only stores the current path, making its space complexity comparable to DFS. This is its primary advantage over A\* for large state spaces.
* **Disadvantages:**
    * **Repeated Work:** It re-expands nodes in successive iterations, but this overhead is often minor for exponential search trees, as the vast majority of work is done at the deepest level.
* **Time Complexity:** Often asymptotically equivalent to A\* ($O(P^D)$ in worst-case heuristic scenarios, but better with a good heuristic). Despite re-expending nodes, the number of nodes at the shallow depths is small compared to the deeper levels, so the total work is usually only a constant factor higher than A\*.
* **Space Complexity:** $O(D \cdot MN)$ or $O(K \cdot MN)$. The space is dominated by the recursion stack, similar to depth-first search, making it much more memory-efficient than A\* for problems with large state spaces.

### Chosen Approach: Kvho's Algorithm (Optimized Depth-First Search with Backtracking)

This application has transitioned from IDA\* to an algorithm inspired by Kvho's highly optimized C implementation, which appears to be a specialized form of Depth-First Search (DFS) with significant performance enhancements tailored for this type of puzzle. While not explicitly an A\* or IDA\* variant, its strength lies in its meticulous state management and pruning.

Key aspects that likely contribute to its superior performance for Shapeshifter:

1.  **Direct Array Indexing and Cache Usage:** The C# port heavily utilizes direct array indexing (e.g., `s.cache[tci][0]`) and pre-computed caches of matrix indices. This allows for extremely fast, in-place modification of the underlying grid state (`mat`) without the overhead of copying entire grid arrays or complex object allocations for each state in the search tree. C# jagged arrays (`int[][]`) are used to effectively simulate the pointer-to-pointer structure of the original C code, providing a performant way to access the relevant grid cells.

2.  **In-Place State Modification and Backtracking:** The algorithm directly modifies the `mat` (grid state) and then "un-modifies" it during backtracking. This avoids the need to explicitly store multiple copies of the grid state in memory, which is a major memory consumer for A* and can still be a factor in IDA* if states are not managed carefully. The `incs` variable acts as a precise counter of "toggles needed" to reach the goal state, serving as a tight bound/heuristic.

3.  **Heuristic Integration and Pruning:** While not a traditional $h(n)$ function, the `incs` variable effectively acts as a highly integrated and precise heuristic. It tracks the exact number of "toggles" (changes from a non-goal token to the goal token) remaining. If at any point applying a token would result in a negative `incs` (meaning more toggles would be needed than available, or a token would "untoggle" a goal cell too many times), that path is immediately pruned. This is a very strong and efficient form of pruning, directly integrated into the core loop.

4.  **Optimized Loop Structure and Minimal Overheads:** The core `FindSeq` loop is extremely tight, minimizing function call overheads and maximizing CPU cache efficiency. The C# implementation leverages techniques like `structs` for `S1` (potential stack allocation for value types), `sealed classes` for `S` (aiding JIT devirtualization), and implicitly benefits from the .NET JIT compiler's ability to perform aggressive inlining and loop unrolling, reducing the instruction count per node expansion significantly compared to more abstract search implementations.

5.  **Problem-Specific Optimizations (Token Order and Equivalence):** The `PrepShapes` function suggests an intelligent pre-processing step, potentially sorting shapes (e.g., by `npts`) and identifying equivalent shapes. This can reduce redundant computations by exploring only unique shape placements and potentially optimizing the order in which tokens are considered, further pruning the search space. The use of `Buffer.BlockCopy` for array copying where appropriate also contributes to performance.

In essence, while IDA\* is a robust and generally effective algorithm, this C# port of Kvho's implementation gains an edge by being meticulously hand-optimized for the specific constraints and mechanics of the Shapeshifter puzzle. It leverages low-level memory access patterns (simulated effectively with jagged arrays), a highly integrated and precise heuristic, and C#-specific performance features that collectively outperform a more general IDA\* framework for this particular problem. The focus shifts from generic graph traversal to highly efficient state manipulation and aggressive pruning within a depth-first search paradigm, all within a safe and managed .NET environment.

---

## Further Reading

* **ShapeShifter algorithm (recursive bruteforce):** [Dr. Plank's lab writeup explanation of ShapeShifter](https://web.archive.org/web/20240418234629/https://web.eecs.utk.edu/~jplank/plank/classes/cs202/Labs/Lab9/)
* **A\* Heuristic search:** [https://www.cs.cmu.edu/~cga/ai-course/astar.pdf](https://www.cs.cmu.edu/~cga/ai-course/astar.pdf)
* **Iterative deepening A\*:** [https://en.wikipedia.org/wiki/Iterative_deepening_A*](https://en.wikipedia.org/wiki/Iterative_deepening_A*)
* **She Who Shapes:** [https://shewhoshapes.wordpress.com/](https://shewhoshapes.wordpress.com/)

---

## Contributions

* **Kvho's DFS Backtracking Algorithm:** [Original C Code](https://raw.githubusercontent.com/jimrustle/neopets-shapeshifter/1c31a419971de3f25cac9a5dfc4fa32ca4aa7605/kvho_ss/ss.c)

---

## License

This project is open-source and available under the MIT License.

**Disclaimer:** "Neopets" is a registered trademarks of Neopets, Inc. This application is an unofficial fan-made helper and is not affiliated with or endorsed by Neopets, Inc.
